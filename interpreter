#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code_filter', <<'__gIaVDqDoWT04Y/vzEYyoyadmT36MLhB1ERa09udQZ9M');
meta::define_form 'code_filter', sub {
  my ($name, $value) = @_;
  *{"code_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__gIaVDqDoWT04Y/vzEYyoyadmT36MLhB1ERa09udQZ9M

meta::meta('datatypes::cpp_section', <<'__iSq5SVn3Vw0i1zHw0zegKAuS4cKl8QE2lqgoLXAYscI');
meta::define_form 'cpp_section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "cpp_section::$name";
  *{$name} = sub {
    edit("cpp_section::$name");
  };
};
__iSq5SVn3Vw0i1zHw0zegKAuS4cKl8QE2lqgoLXAYscI

meta::meta('datatypes::data', <<'__s2euAFkA/SbXvMzOkLZXrqX3TdtBzEODSWBAt7wXECA');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("data::$name")                                  if $_[0] eq 'edit';
    retrieve("data::$name");
  };
};
__s2euAFkA/SbXvMzOkLZXrqX3TdtBzEODSWBAt7wXECA

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::java_section', <<'__+OMNe3P39/PtqlXYIuMYT/tIyOF3QVpZJcXdO0xbkRw');
meta::define_form 'java_section', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "java_section::$name";
  *{$name} = sub {
    edit("java_section::$name");
  };
};
__+OMNe3P39/PtqlXYIuMYT/tIyOF3QVpZJcXdO0xbkRw

meta::meta('datatypes::library', <<'__Uu9nRiHABRn+x19zBWmHpJF8gbfMA5v5MlpNoSE8MqE');
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  $externalized_functions{$name} = "library::$name";
  *{$name} = sub {edit("library::$name")};
  warn $@ if $@;
};
__Uu9nRiHABRn+x19zBWmHpJF8gbfMA5v5MlpNoSE8MqE

meta::meta('datatypes::line_filter', <<'__/k1BhEweDsgaEdqrALbIEjvKhsVrk/hv//e/KPydA6A');
meta::define_form 'line_filter', sub {
  my ($name, $value) = @_;
  *{"line_filter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__/k1BhEweDsgaEdqrALbIEjvKhsVrk/hv//e/KPydA6A

meta::meta('datatypes::list-type', <<'__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w

meta::meta('datatypes::message-color', <<'__nWmJgsP4S3LFdMPQnL+foYc9c5fgqIlEm6RppolzoX0');
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "message_color::$name";
  terminal::color($name, $value);
  *{$name} = sub {
    associate("message_color::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    edit("message_color::$name")                                  if $_[0] eq 'edit';
    retrieve("message_color::$name");
  };
};
__nWmJgsP4S3LFdMPQnL+foYc9c5fgqIlEm6RppolzoX0

meta::meta('datatypes::note', <<'__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34');
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34

meta::meta('datatypes::unlit_converter', <<'__2X1thh9LQ0oUWCfeWj297YwiGJA/klB7hVI2sWEFtEE');
meta::define_form 'unlit_converter', sub {
  my ($name, $value) = @_;
  *{"unlit_converter::$name"} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__2X1thh9LQ0oUWCfeWj297YwiGJA/klB7hVI2sWEFtEE

meta::meta('datatypes::vim-highlighter', <<'__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::_list_type('list', <<'__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk');
list
__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk

meta::bootstrap('initialization', <<'__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc

meta::bootstrap('pod', <<'__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg');

=head1 NAME

object - Stateful file-based object

=head1 SYNOPSYS

object [options] action [arguments...]

object shell

=head1 DESCRIPTION

Stateful objects preserve their state between executions by rewriting themselves. Each time the script exits it replaces its contents with its new state. Thus
state management, for user-writable scripts, is completely transparent.

An object rewrites itself only if its state has changed. This may seem like a dangerous operation, but some checks are put into place to ensure that it goes
smoothly. First, the object is initially written to a separate file. Next, that file is executed and asked to provide a hashsum of its contents. The original
object is rewritten only if that hashsum is correct. This ensures that the replacement object is functional and has the right data.

Currently the only known way to lose your data is to edit the serialization-related functions in such a way that they no longer function. However, this is not
something most people will normally do. In the future there may be a locking mechanism to prevent unintentional edits of these attributes.

=cut

__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg

meta::code_filter('cpp', <<'__RnBPiqLeW7JfaMHW0CgoNF/vpNWmNs4SJULj+/ehEjo');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\scpp(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{cppcode}" if $settings{'begin'};
  } else {
    return '\begin{cppcode}' if $settings{'begin'};
  }

  return '\end{cppcode}' if $settings{'end'};
}

return $line;
__RnBPiqLeW7JfaMHW0CgoNF/vpNWmNs4SJULj+/ehEjo

meta::code_filter('java', <<'__Q16rFeNkyBdV6W9RLL9GKTJwnstfRqIfBpmDbVFNOqQ');
use File::Path 'mkpath';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sjava(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if ($properties{'class'}) {
    my $classname         = $properties{'class'};
    my $package_directory = $properties{'package'};
    $package_directory =~ tr[.][/];

    mkpath(my $directory = &{'source-directory'}() . '/' . $package_directory);
    open my $fh, $settings{'begin'} ? '>' : '>>', "$directory/${classname}.java";
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$properties{package}.$properties{class}}\n\\begin{javacode}" if $settings{'begin'};
  }

  return '\begin{javacode}' if $settings{'begin'};
  return '\end{javacode}'   if $settings{'end'};
}

return $line;
__Q16rFeNkyBdV6W9RLL9GKTJwnstfRqIfBpmDbVFNOqQ

meta::code_filter('resource', <<'__gnuMnVX94wNmeabRscK/Tp+seTmMoqXAeoOdJ+H8ZX0');
use File::Path 'mkpath';
use File::Basename 'dirname';

my ($line, %settings) = @_;

my $settings = $settings{'name'};
if ($settings =~ /\sresource(\s|$)/) {
  my %properties;
  my @keys_and_values = split /\s+/, $settings;
  for (@keys_and_values) {
    my ($k, $v) = split /=/;
    $properties{$k} = $v;
  }

  if (my $filename = $properties{'name'}) {
    mkpath(dirname(my $path = &{'source-directory'}() . "/$filename"));
    open my $fh, $settings{'begin'} ? '>' : '>>', $path;
    print $fh "$line\n" unless $settings{'begin'} || $settings{'end'};
    close $fh;

    return "\\lstset{caption=$filename}\n\\begin{resource}" if $settings{'begin'};
  } else {
    return '\begin{resource}' if $settings{'begin'};
  }

  return '\end{resource}' if $settings{'end'};
}

return $line;
__gnuMnVX94wNmeabRscK/Tp+seTmMoqXAeoOdJ+H8ZX0

meta::code_filter('verbatim', <<'__AON9bxWzZOMpERGSJVrit8dkijYb5Re8IIg2PEC5i1s');
my ($line, %settings) = @_;

unless ($settings{'name'}) {
  return '\begin{verbatim}' if $settings{'begin'};
  return '\end{verbatim}'   if $settings{'end'};
}

return $line;
__AON9bxWzZOMpERGSJVrit8dkijYb5Re8IIg2PEC5i1s

meta::cpp_section('beta', <<'__SrKu1cDcKRUX7g9SZFUDqS7TE8HHND4coME7Tzx5luE');
- $\beta$-Rewrite Representation
  This section outlines the conversion process from a simple $\beta$-rewrite calculus to template metaprogramming constructs. This rewrite system then is combined with an \verb|eval| function
  to form the basis for the metacircular interpreter defined in \Ref{section}{sec:metacircular}.

  - List construct
    The $\beta$ rewrite system assumes the existence of two data types. One is the {\em term}, which corresponds to a value that might get replaced, and the other is a cons cell of two values.
    The first step to modeling these things is defining a cons cell, which for this system is Church-encoded:

    :: cpp name=core/cons.hh
    #ifndef CORE_CONS_HH
    #define CORE_CONS_HH

    #include "module-begin.hh"
    defun(cons, class h, class t) {
      local_defun(closure, class f) {
        ret(call(f, h, t));
      };
      ret(closure);
    };

    defun(head, class h, class t) {ret(h);};
    defun(tail, class h, class t) {ret(t);};

    def(nil) {};
    #include "module-end.hh"

    #endif
    :.

    :: cpp name=tests/core/cons.cc
    #include "core/cons.hh"
    #include "unit/test.hh"

    deftest(cons_instantiation) {
      let(foo,  call(cons, n(5), n(6)));
      let(five, call(head, foo));
      let(six,  call(tail, foo));

      assert_types_equal(five, n(5));
      assert_types_equal(six,  n(6));
      assert_types_equal(foo,  cons(n(5), n(6)));
    };
    :.
__SrKu1cDcKRUX7g9SZFUDqS7TE8HHND4coME7Tzx5luE

meta::cpp_section('cpp-introduction', <<'__dIO7xsJfuJqvPXdHd7TAMttntR4IjRjbT8tXbJv6WXI');
- Introduction to C++ Literate Coding
  The C++ literate code interface is much like the Java one, except that code sections use the \verb|name=x| attribute rather than \verb|class=| and \verb|package=|. The name is expected to
  include an extension, so for example \verb|:: cpp name=src/foo.h| is a correct heading.

  :: cpp name=hello.cc
  #include<iostream>
  int main () {
    std::cout << "Hello world!" << std::endl;
  }
  :.
__dIO7xsJfuJqvPXdHd7TAMttntR4IjRjbT8tXbJv6WXI

meta::cpp_section('introduction', <<'__36lFNhCinAJc2hlpemtaX2ZxHW/pZ5qFDb/SlqXBEVM');
- Introduction to Template Patterns
  \label{sec:introduction}
  Template expansion provides a pure untyped lambda calculus. All equality is extensional and the calculus supports higher-order functions (templates) with annotations at invocation, but not
  declaration, time.\footnote{This makes it untyped. C++ templates also support function types using nested template syntax -- see \Ref{section}{sec:higher-order-function-types}.} This section
  goes over the encoding of lambda calculus in the template system.

  - Encoding constants
    Constants are simply \verb|struct|s, \verb|class|es, or other types that don't take template parameters. It isn't a problem if they do take template parameters, of course; those will
    simply be specified later once the constant has propagated through the lambda expansion.

    :: cpp name=examples/introduction/constants.hh
    // Defining a constant term
    struct foo {
      enum {value = 10};
    };

    // Defining a global constant also_foo = foo
    typedef foo also_foo;

    // Defining two templated terms that act as constants
    template<class t> struct has_a_field {
      t field;
    };

    template<int n> struct has_a_number {
      enum {number = n};
    };
    :.

  - First-order function encoding
    The idea is to have \verb|struct|s that represent terms of the calculus. If they are templates, then they represent functions (which are also terms). For example:

    :: cpp name=examples/introduction/first-order-functions.cc
    #include <iostream>
    #include "constants.hh"

    // Defining the identity function, where the result
    // can be retrieved by specifying bar<T>::type
    template<class t> struct bar {
      typedef t type;
    };

    // Defining a global constant identity_result = bar(also_foo)
    typedef bar<also_foo>::type identity_result;

    int main () {
      std::cout << "foo::value             = " <<
                    foo::value                 << std::endl <<
                   "also_foo::value        = " <<
                    also_foo::value            << std::endl <<
                   "identity_result::value = " <<
                    identity_result::value     << std::endl;
    }
    :.

    In practice there is some difficulty already. Notice the use of \verb|::type| to retrieve the value of a function application. This slot had to be assumed by the caller; it is similar to
    JavaScript code like this:

    :: resource name=examples/introduction/unfriendly-identity.js
    // An unfriendly identity function.
    var identity = function (x) {
      return {type: x};
    };

    // Invocations must now look like this:
    var y = identity(x).type;
    :.

    Having issues like this percolating through the design can be a real problem. Unless the slot is passed to every invocation site,\footnote{It also must be forwarded, which isn't possible
    in C++ to the best of my knowledge.} invocations will be divergent and will create errors. This means that return values should be unified to a single slot, in this library (and the Boost
    MPL) called \verb|::type|.\footnote{This may seem counter-intuitive, since the types here encode values in lambda-calculus. However, it does serve a mnemonic purpose later when value types
    are used as template parameters, and dependent value-type relations are established. Once this happens it becomes useful to explicitly distinguish between type template parameters and
    value template parameters.}

    So we establish some conventions up front. Whenever you define a constant, it is used as-is without a contained \verb|typedef| that we have to know about. This is OK because we shouldn't
    ever make assumptions about the members of types that are used as template parameters.

  - Higher-order function encoding
    Higher-order functions are possible by encoding slots for invocations.\footnote{This is equivalent to the distinction between pure, extensional object-oriented programming and pure,
    extensional functional programming. In the latter, term juxtaposition (e.g. {\tt f x}) constitutes invocation of the default slot, generally referred to as {\em apply}. In the former,
    slots are explicitly named, as would be the case in a language such as Java -- thus juxtaposition has no meaning on its own.} We do this by declaring another template inside the first:

    :: cpp name=examples/introduction/higher-order-functions.cc
    #include <iostream>
    #include "constants.hh"

    // Defining the K combinator
    template<class t>
    struct k {
      template<class u>
      struct apply {
        typedef t type;
      };
    };

    // Using that on two types
    typedef has_a_number<5> t1;
    typedef has_a_number<6> t2;
    typedef k<t1>::apply<t2>::type should_be_t1;

    int main () {
      std::cout << "t1::number           = " << t1::number           << std::endl <<
                   "should_be_t1::number = " << should_be_t1::number << std::endl;
    }
    :.

    In this example, \verb|k| has a call slot \verb|apply| that ultimately provides the value. So, for example, \verb|k<x>::apply<y>::type| is equivalent to the more concise \verb|k x y| in
    Haskell, or \verb|((k x) y)| in Scheme.

    At this point it should be clear that nothing is standardized here. Top-level functions are invoked directly, whereas returned functions use \verb|::apply<x>|. Type results from template
    invocations are accessed as \verb|::type|. One way to go about fixing it is to make a rule that a function gets encoded a bit less directly:

    :: cpp name=examples/introduction/indirect-functions-broken.cc
    // Encoding the K combinator uniformly, but with compile errors
    struct k {
      template<class t>
      struct apply {
        template<class u>
        struct apply {
          typedef t type;
        };
      };
    };
    :.

    However, if you compile it you get an error stating that you can't define a nested \verb|struct| with the same name as the outer one. The solution is to use an intermediate \verb|::type|
    dereference to wrap the inner \verb|::apply<x>|.

    :: cpp name=examples/introduction/indirect-functions.cc
    #include <iostream>
    #include "constants.hh"

    // Encoding the K combinator uniformly
    struct k {
      template<class t>
      struct apply {
        struct type {
          template<class u>
          struct apply {
            typedef t type;
          };
        };
      };
    };

    typedef has_a_number<5> t1;
    typedef has_a_number<6> t2;
    typedef k::apply<t1>::type::apply<t2>::type should_be_t1;

    int main () {
      std::cout << "t1::number           = " << t1::number           << std::endl <<
                   "should_be_t1::number = " << should_be_t1::number << std::endl;
    }
    :.

    At this point a nice pattern emerges. Whenever we apply a function to something, we get its \verb|::type| as well. So constants map to themselves, and function invocations are all of the
    form \verb|f::apply<...>::type|.

  - Higher-order function type signatures
    \label{sec:higher-order-function-types}
    C++ lets you specify type signatures for higher-order templates. This can be useful to ensure that a function possesses at least a certain Church arity\footnote{I use this term to refer to
    the arity of the uncurried form of the function. For example, the Church arity of $\lambda x. \lambda y. x$ is 2, since uncurrying yields $\lambda(x,y).x$.} or takes at least so many
    arguments. It also provides some notational convenience at invocation-time.

    Here is the Haskell function that we will model in C++ templates:

    :: resource name=examples/introduction/apply-two-function.hs
    apply_two :: ((a, a) -> b) -> a -> b
    apply_two f x = f (x, x)
    :.

    In template metaprogramming it isn't possible to express the constraints about values, but we can express constraints about arity and function status:

    :: cpp name=examples/introduction/apply-two-function.cc
    #include <iostream>
    #include "constants.hh"

    // Encoding the type signature as a template parameter specification
    struct apply_two {
      template<template<class arg1, class arg2> class f>
      struct apply {
        struct type {
          template<class x>
          struct apply {
            typedef f<x, x> type;
          };
        };
      };
    };

    // An example value for f
    template<class x, class y>
    struct sample_f {
      typedef x x_type;
      typedef y y_type;
    };

    typedef has_a_number<10> t1;
    typedef has_a_number<12> t2;
    typedef apply_two::apply<sample_f>::type::apply<t1>::type two_of_t1;

    int main () {
      std::cout << "t1::number                = " << t1::number << std::endl <<
                   "two_of_t1::x_type::number = " << two_of_t1::x_type::number << std::endl <<
                   "two_of_t1::y_type::number = " << two_of_t1::y_type::number << std::endl;
    }
    :.

    The parameter definition \verb|<template<class arg1, class arg2> class f>| is equivalent to the Haskell type signature \verb|f :: (a, b) -> c|; none of the individual types are specified,
    but the template must be invoked on two parameters or not invoked at all.\footnote{Note that at this point I'm not referring to invocation using the {\tt ::apply} convention established
    earlier. This invocation is just regular template expansion.} The other thing of note is that you can arbitrarily refine the left-hand side; for example:
    
    ::
    template<template<template<class x> class f,
                      template<class y> class g> class compose>
    struct composer {...};
    :.

    This is equivalent to \verb|composer :: ((a -> b), (c -> d)) -> e|. As far as I know there is no way to specify anything about the return type of a function using template syntax.

    I'm not using template types in this project for a couple of reasons. First, declaring formals uses names (I'm actually not sure whether those names are considered reserved by C++, but I
    assume so). Second, it isn't possible to encode slot types, and all invocation in the lambda-calculus encoding is done with the \verb|::apply| slot.

  - Conditionals
    Templates don't model conditionals {\em per se}. Rather, you can create conditionals by using pattern matching and explicit specialization. There are some weird limitations about this, but
    here is the basic idea:

    :: cpp name=examples/introduction/specialization.cc
    #include <iostream>
    #include "constants.hh"

    // General case
    template<class t>
    struct piecewise {
      typedef t type;
    };

    // When t = has_a_number<50>, do this instead
    template<>
    struct piecewise<has_a_number<50>> {
      typedef has_a_number<100> type;
    };

    typedef piecewise<has_a_number<3>>::type  general;
    typedef piecewise<has_a_number<50>>::type specialized;

    int main () {
      std::cout << "general::number     = " << general::number     << std::endl <<
                   "specialized::number = " << specialized::number << std::endl;
    }
    :.

    - Limitations of inner specialization
      \label{sec:limitations-of-inner-specialization}
      Because terminal (i.e.~non-expanding) types are extensionally equivalent, pattern matching can be used to reliably specialize template expansions. The only case where this doesn't work
      is inside a class:

      :: cpp name=examples/introduction/inner-specialization-broken.cc
      template<class t>
      struct container {
        template<class u>
        struct piecewise {
          typedef u type;
        };

        // Compiler complains about this:
        template<>
        struct piecewise<int> {
          typedef t type;
        };
      };

      typedef container<int>::piecewise<int>::type foo;
      :.

      The solution to this problem is to break the inner class outside of the outer one and uncurry its arguments:

      :: cpp name=examples/introduction/inner-specialization.cc
      #include <iostream>
      #include "constants.hh"

      namespace inside_container {
        template<class t, class u>
        struct piecewise {
          typedef u type;
        };

        template<class t>
        struct piecewise<t, int> {
          typedef t type;
        };
      }

      template<class t>
      struct container {
        template<class u>
        struct piecewise {
          typedef typename inside_container::piecewise<t, u>::type type;
        };
      };

      typedef has_a_number<1> t1;
      typedef has_a_number<2> t2;
      typedef container<t1>::piecewise<t2>::type  general;
      typedef container<t1>::piecewise<int>::type specialized;

      int main () {
        std::cout << "general::number     = " << general::number     << std::endl <<
                     "specialized::number = " << specialized::number << std::endl;
      }
      :.

      The namespace here isn't necessary, but it hides what normally gets hidden when you create an anonymous closure. Also notice that it must be declared before \verb|container| due to C++'s
      forward-reference semantics.\footnote{Despite this, template expansion is generally lazy in other ways.}
__36lFNhCinAJc2hlpemtaX2ZxHW/pZ5qFDb/SlqXBEVM

meta::cpp_section('preprocessor', <<'__VfRFA0Yt3Ba0czpsWlZsv/6I3Cl1PF+Q2KjNMncmmOs');
- Preprocessor Definitions
  \label{sec:preprocessor-definitions}
  The goal of this section is to implement a layer of abstraction over the base template constructs. Roughly, the operations are:

  e[
    + Defining a global constant
    + Defining a local variable
    + Applying a function to an expression \label{itm:apply-function-to-expression}
    + Returning a value from a function
    + Defining a named function
  ]e

  Each of these operations has a standard form.\footnote{There are two for \Ref{item}{itm:apply-function-to-expression}; one form is used outside of a function body and the other is used
  inside. The difference has to do with disambiguating template expansions and is covered in \Ref{section}{sec:function-application}. Also a great article about the role of {\tt typename} in
  C++, its uses, and its limitations: \url{http://pages.cs.wisc.edu/~driscoll/typename.html}.} The definition of a shorthand for each is given in the following subsections.

  - Preprocessor limitations
    One notable limitation of the C preprocessor when working with templates is that it doesn't treat \verb|<| and \verb|>| as nested parentheticals.\footnote{It wouldn't be possible for it to
    do the right thing here anyway, since the preprocessor sees code before types have been defined. However, template punctuation was an unfortunate choice considering its ambiguity with
    relational operators, and the fact that relational operators are always ungrouped while template parameter delimiters are always grouped.} This has the unfortunate effect of splitting on
    commas that separate template parameters, e.g.:

    ::
    #define f(x) ...

    template<class x, class y>
    struct foo {...};

    f(foo<bar, bif>);   // Error here; too many arguments
    :.

    In value-space you can deal with this by explicitly parenthesizing expressions, but parentheses aren't a transparent construct in type-space. The way I'm getting around this for now is to
    make macros variadic and always put any template invocations at the end:

    ::
    #define f(x...) typedef x bar;
    :.

    This will preserve the commas in the original expression, although its use may be limited to the GNU preprocessor.\footnote{A more standard way to do this is to use the {\tt
    \_\_VA\_ARGS\_\_} builtin and an anonymous ellipsis.}

    Another limitation has to do with brace matching. In order to write syntax in a natural way, it is helpful to write macros that behave more or less with standard C syntax; that is, the
    block occurs after the macro invocation:

    ::
    macro_invocation(x, y, z) { block }
    :.

    However, a problem arises when the macro is responsible for expanding two sets of braces, as might be the case for a nested \verb|struct|:

    ::
    // Need to generate this code:
    struct foo {
      struct bar { stuff };
    };

    // This macro definition won't do it:
    #define generate() \
      struct foo { \
        struct bar

    // This code:
    generate() {
      stuff
    };

    // Expands to this:
    struct foo {
      struct bar {
        stuff
      };
          // <- No closing brace!
    :.

    However, certain cases where this would have been used can be worked around. It comes into play when defining templates as functions; see \Ref{section}{sec:defun}.

  - Global constants
    \label{sec:global-definitions}
    A global constant is just a standalone \verb|struct|. To encode this, we create the \verb|def()| macro, which basically just expands out to \verb|struct|. However, it is a bit clearer than
    its expansion, especially in the context of defining functions and values.

    This module, like all of the preprocessor utilities, can be enabled and disabled multiple times during preprocessing. This prevents the macros from interfering with regular code, which
    ultimately enables clearer macro naming. The mechanism that governs enabling and disabling is the \verb|LISP_PREPROCESSOR_DEFINE| preprocessor variable. If defined, then the header is run
    in ``definition mode'' and will create macros. Otherwise it will undefine the macros. You can see whether a macro is defined as well; each header file defines a macro called
    \verb|LISP_PREPROCESSOR_X_ENABLED|, where \verb|X| is the upper-case name of the header file. This macro is undefined when the header is disabled.

    Note that you shouldn't ever include this header file directly. See \Ref{section}{sec:preprocessor-interface} for a simple interface to enable and disable preprocessor macros.

    :: cpp name=preprocessor/def.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #  define LISP_PREPROCESSOR_DEF_ENABLED
    #  define def(name) struct name
    #else
    #  undef  LISP_PREPROCESSOR_DEF_ENABLED
    #  undef  def
    #endif
    :.

  - Local variables
    Within a \verb|struct|, local variables are prefixed with \verb|private|.

    :: cpp name=preprocessor/let.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #  define LISP_PREPROCESSOR_LET_ENABLED
    #  define let(name, value...) private: typedef value name
    #  define local_def(name)     private: struct name
    #else
    #  undef  LISP_PREPROCESSOR_LET_ENABLED
    #  undef  let
    #  undef  local_def
    #endif
    :.

  - Function application
    \label{sec:function-application}
    It is assumed that function application involves dependent types.\footnote{In the C++ sense, not the type-theoretic sense. C++ dependent types are the transitive closure of template
    variables through the expansion graph.} In that case, the default \verb|call(x, ...)| works fine. If, however, the function call's types are already resolved and do not depend on template
    variables, then you will probably want to use \verb|call_static| instead.

    :: cpp name=preprocessor/call.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #  define LISP_PREPROCESSOR_CALL_ENABLED
    #  define call(lhs, rhs...) typename lhs::template apply<rhs>::type
    #  define call_static(lhs, rhs...) lhs::apply<rhs>::type
    #else
    #  undef  LISP_PREPROCESSOR_CALL_ENABLED
    #  undef  call
    #  undef  call_static
    #endif
    :.

  - Returning a value
    It is straightforward to return a named value. This always takes the form \verb|typedef x type|, where \verb|x| is the value to be returned. For simplicity's sake, I'm going to assume that
    whatever value should be returned has a name to preserve the uniformity of the return expansion. Note that it is prefixed with \verb|public| to override any previous local variables that
    were defined.

    :: cpp name=preprocessor/ret.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #  define LISP_PREPROCESSOR_RET_ENABLED
    #  define ret(value...) public: typedef value type
    #else
    #  undef  LISP_PREPROCESSOR_RET_ENABLED
    #  undef  ret
    #endif
    :.

  - Defining a named function
    To remain in the mindset of the model C++ uses for template specialization, defining a named function is a two-step process. First, you define the outer \verb|struct| using \verb|def()|
    (see \Ref{section}{sec:global-definitions}). Inside that you can specify the cases using the \verb|when()| macro.

    :: cpp name=preprocessor/when.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #  define LISP_PREPROCESSOR_WHEN_ENABLED
    #  define when(parameters...) template <parameters> struct apply
    #else
    #  undef  LISP_PREPROCESSOR_WHEN_ENABLED
    #  undef  when
    #endif
    :.

  - Defining and returning closures
    \label{sec:defun}
    It is fairly simple to return a closure. The idea is that you create a local named function and then return that by name, so to implement the K combinator, for example, you would do
    something like this:

    ::
    def(k) {
      when(class x) {
        local_def(inner) {
          when(class y) {
            ret(x);
          };
        };

        ret(inner);
      };
    };
    :.

    However, that's a bulky representation given that no explicit specialization is occurring. It would be tempting to implement a \verb|defun| macro like this:

    ::
    #define defun(name, params...) \
      def(name) {}; \
      template<params> struct name::apply
    :.

    \noindent however C++ doesn't allow you to define inner \verb|struct|s after the fact.\footnote{While it might allow a forward definition for a normal {\tt struct}, this isn't possible for
    a templated {\tt struct}, so we're back to square one.}

    Here's a shot in the dark:

    :: cpp name=preprocessor/defun.hh
    #ifndef LISP_PREPROCESSOR_DEFUN_ENABLED
    #  define LISP_PREPROCESSOR_DEFUN_ENABLED
    #  define defun(name, params...) \
         def(name) {typedef name##_apply apply;}; \
         template<params> struct name##_apply
    #  define local_defun(name, params...) \
         local_def(name) {typedef name##_apply apply;}; \
         template<params> struct name##_apply
    #endif
    :.

  - Preprocessor interface
    \label{sec:preprocessor-interface}
    Rather than using the files above, it's better to include these header files to enable or disable the preprocessor macros.

    :: cpp name=preprocessor-enable.hh
    #ifndef LISP_PREPROCESSOR_DEFINE
    #define LISP_PREPROCESSOR_DEFINE
    #include "preprocessor/all.hh"
    #endif
    :.

    :: cpp name=preprocessor-disable.hh
    #ifdef LISP_PREPROCESSOR_DEFINE
    #undef LISP_PREPROCESSOR_DEFINE
    #include "preprocessor/all.hh"
    #endif
    :.

    This file is used internally to include all of the modules listed in the previous subsections:

    :: cpp name=preprocessor/all.hh
    #include "preprocessor/def.hh"
    #include "preprocessor/let.hh"
    #include "preprocessor/call.hh"
    #include "preprocessor/ret.hh"
    #include "preprocessor/when.hh"
    #include "preprocessor/defun.hh"
    :.

  - Core interface
    These headers contain things to abstract away the process of defining modules. Usage is like this:

    ::
    #include "module-begin.h"
    // module code
    #include "module-end.h"
    :.

    :: cpp name=module-begin.hh
    #include "preprocessor-enable.hh"
    namespace lisp {
    :.

    :: cpp name=module-end.hh
    }
    #include "preprocessor-disable.hh"
    :.
__VfRFA0Yt3Ba0czpsWlZsv/6I3Cl1PF+Q2KjNMncmmOs

meta::cpp_section('resources', <<'__1OSnhHIgmujRK2Yo5xQy10wNNh3XGEOAYTmVJVTiCS0');
- Resources
  \label{sec:resources}
  This section contains extra files that are helpful for running the examples. Note that this library requires your version of \verb|gcc| to support a fairly recent C++0x draft, as specified
  by \verb|-std=gnu++0x|.

  - Makefile for introduction examples
    This makefile will build all of the examples in \Ref{section}{sec:introduction}. It is available in the source distribution as \verb|src/examples/introduction/makefile|, and should be run
    from inside \verb|src/examples/introduction|. Alternatively, all of the examples can be compiled by using the makefile in \verb|src/examples|.

    :: resource name=examples/introduction/makefile
    WORKING  = first-order-functions higher-order-functions indirect-functions \
               apply-two-function specialization inner-specialization fibonacci \
               fibonacci-piecewise linked-list church-lists

    BROKEN   = indirect-functions-broken inner-specialization-broken \
               fibonacci-piecewise-broken self-reference-broken

    BASE_DIR = ../../
    CC       = g++
    CC_OPTS  = -g -Wall -std=gnu++0x -I$(BASE_DIR)

    all: $(WORKING)
    broken: $(BROKEN)

    .PHONY: clean
    clean:
    	rm -f $(WORKING) $(BROKEN)

    %: %.cc
    	$(CC) $(CC_OPTS) $< -o $@ || true
    :.

  - Makefile for tests
    This makefile builds the unit and integration tests for the Lisp implementation. The tests should fail at compile-time if an assertion is not satisfied. This file should be run from
    \verb|src/tests|.

    :: resource name=tests/makefile
    UNIT        = core/cons
    INTEGRATION =

    BASE_DIR    = ../
    CC          = g++
    CC_OPTS     = -g -Wall -std=gnu++0x -I$(BASE_DIR)

    all: $(UNIT) $(INTEGRATION)

    .PHONY: clean
    clean:
    	rm -f $(UNIT) $(INTEGRATION)

    %: %.cc
    	$(CC) $(CC_OPTS) $< -o $@ || true
    :.
__1OSnhHIgmujRK2Yo5xQy10wNNh3XGEOAYTmVJVTiCS0

meta::cpp_section('tests', <<'__QYN92TVFqBLkeTe26gl2jaUVpp09dvRbD3WonT1czYA');
- Unit and Integration Tests
  This section defines a basic unit and integration test library with assertions to test equality of expressions in type-space.\footnote{Since value-dependent types are pure with respect to
  values, and values are pure with respect to types, this is sufficient to test static values contained within those types as well.} It defines some macros that make it very easy to write
  tests, and enables the preprocessor macros defined in \Ref{section}{sec:preprocessor-definitions}.

  - Type equivalence
    A good approximation for type equivalence is whether a container expanded with one type is assignable to that container expanded with another type (and vice versa, to cover any
    co/contravariance). This should capture the extensionality of type equivalence without admitting any possibilities that are substantially different.

    :: cpp name=unit/type-equivalence.hh
    #ifndef UNIT_TYPE_EQUIVALENCE_HH
    #define UNIT_TYPE_EQUIVALENCE_HH

    namespace lisp {
    namespace unit {

    template <class c1, class c2>
    class type_equality_assertion_failed_ {
      c1 the_left_hand_side_;
      c2 the_right_hand_side_;

      void when_testing_assignability () {
        the_left_hand_side_ = the_right_hand_side_;
        the_right_hand_side_ = the_left_hand_side_;
      }
    };

    }
    }

    #define assert_types_equal(types...) \
      typedef ::lisp::unit::type_equality_assertion_failed_<types...> \
              type_equality_check_##__LINE__;

    #endif
    :.

  - {\tt deftest}
    This is a quick way to create a scope for running unit tests. The semantic is just like \verb|def()| from \Ref{section}{sec:global-definitions}, except that the result is placed in the
    namespace \verb|::lisp::unit::defined_tests| to avoid collision.

    :: cpp name=unit/deftest.hh
    #ifndef UNIT_DEFTEST_HH
    #define UNIT_DEFTEST_HH

    #define deftest(name) struct ::lisp::unit::defined_tests::name

    #endif
    :.

  - Test definitions
    Unit tests should have minimal boilerplate, ideally just one \verb|#include|. This header takes care of importing all of the stuff that would otherwise be test boilerplate.

    :: cpp name=unit/test.hh
    #ifndef UNIT_TEST_HH
    #define UNIT_TEST_HH

    #include "preprocessor-enable.hh"

    #include "unit/type-equivalence.hh"
    #include "unit/deftest.hh"

    namespace lisp {
    namespace unit {
    namespace defined_tests {
    }
    }
    }

    using namespace lisp;
    using namespace lisp::unit;

    #endif
    :.
__QYN92TVFqBLkeTe26gl2jaUVpp09dvRbD3WonT1czYA

meta::cpp_section('value-space', <<'__VXN1jkOa9voMVMDxjWV3BBEugkXKkypIxjzx3L48eu0');
- Metaprogramming in Value Space
  Without using any particular encoding, this section provides a few examples of template metaprogramming in action. Each example has been factored down by preprocessor macros to show the
  structure of the code. Also, these examples are not necessarily representative of best practices, nor do they scale well.

  - Fibonacci numbers (explicit specialization)
    \label{sec:fibonacci-explicit}
    This is some metaprogramming in value-space. Constants are evaluated and folded at compile-time, so the \verb|expression| term below can be used to perform arithmetic evaluation. This
    example defines one general form of \verb|fibonacci|, and two specific forms for an inductive process with two base cases. It also shows the lack of generality of piecewise definitions;
    while it is possible to specify a template for given values, implementing the classic compact definition of the function:

    $$ f(n) = \begin{cases} f(n-1) + f(n-2) & n \ge 2 \\
                            n               & n <   2 \end{cases} $$

    \noindent is not possible through specialization without enumerating every value of $n$ below or above 2. In this section we implement a more straightforward definition:

    $$ f(n) = \begin{cases} 0               & n = 0 \\
                            1               & n = 1 \\
                            f(n-1) + f(n-2) & \text{otherwise} \end{cases} $$

    The compact definition is possible, however. The key is to encode that condition separately and specialize on a boolean parameter. That is implemented in
    \Ref{section}{sec:fibonacci-piecewise}.

    :: cpp name=examples/introduction/fibonacci.cc
    #include <iostream>

    #define letrec(name, params, defaults, expression) \
      template params \
      struct name defaults { \
        enum { value = expression }; \
      };

    #define call(name, params...) (name<params>::value)

    letrec(fibonacci, <int n>, , call(fibonacci, n - 1) + call(fibonacci, n - 2))
    letrec(fibonacci, <>, <0>, 0)
    letrec(fibonacci, <>, <1>, 1)

    int main () {
      std::cout << "fibonacci<10>::value = " << fibonacci<10>::value << std::endl;
    }
    :.

  - Fibonacci numbers (piecewise definition)
    \label{sec:fibonacci-piecewise}
    As mentioned in \Ref{section}{sec:fibonacci-explicit}, it is possible to encode the Fibonacci function using a general conditional instead of explicitly specializing the two base values of
    0 and 1. This example doesn't motivate its full utility (better would be a densely piecewise function such as the absolute value), but you can easily extrapolate from the design pattern.

    The first step is to isolate the cases. For the piecewise Fibonacci function:

    $$ f(n) = \begin{cases} n               & n < 2 \\
                            f(n-1) + f(n-2) & n \ge 2 \end{cases} $$

    A boolean contains enough information to encode which branch should be taken. I'll use $n < 2$ as the predicate, so a value of \verb|true| should result in $n$ while a value of
    \verb|false| should result in $f(n-1) + f(n-2)$.

    Here is the obvious way to go about it, though it doesn't work because of mutual dependencies in the definitions:

    :: cpp name=examples/introduction/fibonacci-piecewise-broken.cc
    template <bool n_lt_2, int n>
    struct fibonacci_case {
      enum { value = fibonacci<n - 1>::value + fibonacci<n - 2>::value };
    };

    template <int n>
    struct fibonacci_case <true, n> {
      enum { value = n };
    };

    template <int n>
    struct fibonacci {
      enum { value = fibonacci_case<(n < 2), n>::value };
    };
    :.

    C++ needs to know about template types before you hit them. Because there isn't a way to forward-define templates, we have to get a little bit more creative:

    :: cpp name=examples/introduction/fibonacci-piecewise.cc
    #include <iostream>

    template <class f, bool n_lt_2, int n>
    struct fibonacci_case {
      enum { value = f::template recursive<n - 1>::value +
                     f::template recursive<n - 2>::value };
    };

    template <class f, int n>
    struct fibonacci_case <f, true, n> {
      enum { value = n };
    };

    struct fibonacci_piecewise {
      template <int n>
      struct recursive {
        enum { value = fibonacci_case<fibonacci_piecewise, (n < 2), n>::value };
      };
    };

    template <int n>
    struct fibonacci {
      enum { value = fibonacci_piecewise::template recursive<n>::value };
    };

    int main () {
      std::cout << "fibonacci<10>::value = " << fibonacci<10>::value << std::endl;
    }
    :.

    Note the wrapping of \verb|fibonacci_piecewise::recursive|. This is necessary because within the scope of a template, the name of the templated construct refers to the specialized form,
    not the template itself. For example:

    :: cpp name=examples/introduction/self-reference-broken.cc
    template <int n>
    struct foo {
      typedef foo bar;
    };

    typedef foo<10>::bar should_be_a_template;
    typedef should_be_a_template<10> problem;
    :.

    In this example, \verb|should_be_a_template| isn't a template at all; it's the expanded form of \verb|foo|, which has already been specialized to \verb|foo<10>|. The compiler complains
    when \verb|typedef|ing \verb|problem| because we are trying to expand something that isn't a template.

    The solution is to wrap the template inside a non-template outer \verb|struct|, as the working Fibonacci example demonstrates. This enables you to refer unambiguously to the outer
    \verb|struct| and then explicitly dereference the inner template, which will not be specialized at that point.

  - Linked list
    This is a simple model of a data structure in value-space. For scalability it would be better to use types for the head and tail, but for simplicity the example is restricted to using
    values.

    The \verb|q| function in this example works around a limitation of the preprocessor. \Ref{Section}{sec:preprocessor-limitations} covers this in more detail.

    :: cpp name=examples/introduction/linked-list.cc
    #include <iostream>

    #define function(name, params, values...) \
      template <params> \
      struct name { \
        enum { values }; \
      }

    // Prevents commas from separating the arguments:
    #define q(args...) args
    
    function(cons, q(class X, class Y), car = X::value, cdr = Y::value);
    function(car, class T, value = T::car);
    function(cdr, class T, value = T::cdr);
    function(int_wrapper, int n, value = n);

    int main () {
      std::cout << "car(cons(5, 6)) = " <<
                   car<cons<int_wrapper<5>, int_wrapper<6>>>::value << std::endl;
    }
    :.

  - Church-encoded lists, {\tt map}, and {\tt filter}
    This is a more involved example that uses curried templates and a Church encoding. Note the transition between value-space and type-space achieved by using \verb|select|. \verb|select|
    effectively serves as a map from \verb|bool| to either \verb|head| or \verb|tail|.

    :: cpp name=examples/introduction/church-lists.cc
    #include <iostream>

    #define fn(args...)        template <args> struct
    #define lambda(args...)    template <args> struct apply

    #define lift(name, xs...)  template <xs> class name
    #define call(v, xs...)     typename v::template apply<xs>::type

    #define let(var, value...) private: typedef value var
    #define ret(value...)      public:  typedef value type
    #define val(e)             public:  struct type { enum { value = e }; }

    struct head {lambda(class h, class t) {ret(h);};};
    struct tail {lambda(class h, class t) {ret(t);};};

    namespace _select {
      lambda(bool b)   {ret(head);};
      lambda() <false> {ret(tail);};
    }

    struct select {
      lambda(class t) {ret(call(_select, t::type::value));};
    };

    fn(class h, class t) cons {
      lambda(class f) {
        ret(call(f, h, t));
      };
    };

    struct nil {
      typedef int type;
    };

    struct map {
      lambda(class f, class cell) {
        let(mapped_head, call(f, call(cell, head)));
        let(mapped_tail, call(map, f, call(cell, tail)));
        ret(cons<mapped_head, mapped_tail>);
      };

      lambda(class f) <f, nil> {
        ret(nil);
      };
    };

    struct filter {
      lambda(class f, class cell) {
        let(h,             call(cell, head));
        let(filtered_tail, call(filter, f, call(cell, tail)));
        let(choices,       cons<cons<h, filtered_tail>, filtered_tail>);
        let(selector,      call(select, call(f, h)));

        ret(call(choices, selector));
      };

      lambda(class f) <f, nil> {
        ret(nil);
      };
    };

    fn(int n) int_wrap {
      val(n);
    };

    fn(class x) plus {
      lambda(class y) {
        val(x::type::value + y::type::value);
      };
    };

    fn(int n) is_divisible_by {
      lambda(class x) {
        val(x::type::value % n == 0);
      };
    };

    int main () {
      typedef cons<int_wrap<5>, cons<int_wrap<6>, nil>>      the_list;
      typedef plus<int_wrap<6>>                              the_function;
      typedef is_divisible_by<3>                             the_criterion;
      typedef filter::apply<the_criterion, the_list>::type   the_short_list;
      typedef map::apply<the_function, the_short_list>::type the_result;
      typedef the_result::apply<head>                        should_be_seven;

      std::cout << "head(map(x -> x + 6, filter(x % 3 == 0, list(5, 6)))) = " <<
                   should_be_seven::type::value << std::endl;
    }
    :.

    The use of \verb|cons| to represent the possible outcomes of a decisional isn't a new idea. It's key to the use of \verb|select|, which will return either \verb|head| or \verb|tail|. We
    then apply the cons cell to that outcome to obtain the conditional result. The only problem with this approach is that both possibilities end up getting evaluated regardless of the
    condition. So in general, church-encodings of booleans and other conditionals has the caveat that it may cause infinite recursion. Most conditionals should probably be implemented using
    specialization (see \Ref{section}{sec:fibonacci-piecewise}) to avoid this problem.
__VXN1jkOa9voMVMDxjWV3BBEugkXKkypIxjzx3L48eu0

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('document', <<'__cOk7iLdz8exPc6NYX3bIgFzgqOJLec15R8alfNxEQcw');
= C++ Template Lisp Interpreter
a Spencer Tipping
begin

%section(cpp_section::introduction)
%section(cpp_section::value-space)
%section(cpp_section::preprocessor)
%section(cpp_section::tests)
%section(cpp_section::beta)
%section(cpp_section::resources)
__cOk7iLdz8exPc6NYX3bIgFzgqOJLec15R8alfNxEQcw

meta::data('header', <<'__HlC/zSnFNAXNbuJ/z8ZYgHsD5DWMisPBSt/xyoy+0cw');
\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}

\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\lstnewenvironment{javacode}{\lstset{language=java}}{}
\lstnewenvironment{cppcode} {\lstset{language=c++}} {}
\lstnewenvironment{resource}{}{}
__HlC/zSnFNAXNbuJ/z8ZYgHsD5DWMisPBSt/xyoy+0cw

meta::data('meta-associations', <<'__DVlfIHkYXJ4+o/MvyDFYl59WCQmDx7HU8XchAsqz9/w');
^function:: .pl
^library:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^data::document$ .cltex
^vim_highlighter:: .vim
^java_section:: .javatex
^cpp_section:: .cpptex
^unlit_converter:: .pl
^line_filter:: .pl
^code_filter:: .pl
^profile:: .pl
^data::header$ .tex
__DVlfIHkYXJ4+o/MvyDFYl59WCQmDx7HU8XchAsqz9/w

meta::data('name', <<'__lmbZ6ImUR3NcuYl7d9uxIXVP1NUDYJdYdVvT/a46SyI');
interpreter
__lmbZ6ImUR3NcuYl7d9uxIXVP1NUDYJdYdVvT/a46SyI

meta::data('output-dir', <<'__6WcazSRIScVxZ8ZY+i+Wl1IEj3qxhKPc9cRstNVq4SQ');
/tmp
__6WcazSRIScVxZ8ZY+i+Wl1IEj3qxhKPc9cRstNVq4SQ

meta::data('pdf-output-file', <<'__B060UscZqlVj9zZGAMv6ShFt0KaL+yE9vns0ZipZWU8');
/tmp/interpreter.EzDm1Pu77W1gyujLHbNlkjJnNZhB27ZoS9S6XFOsNbo/document.pdf
__B060UscZqlVj9zZGAMv6ShFt0KaL+yE9vns0ZipZWU8

meta::data('pdf-reader', <<'__BlFO10Obn0hAHVxLShDpKtlpv0BTeJ7iqm1v7vjCM+A');
evince
__BlFO10Obn0hAHVxLShDpKtlpv0BTeJ7iqm1v7vjCM+A

meta::data('pdftex', <<'__aHolEJEGN4wnHiydZyVzwRrETVuJhJOGo/nKL9tsLRY');
pdflatex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__aHolEJEGN4wnHiydZyVzwRrETVuJhJOGo/nKL9tsLRY

meta::data('source-directory', <<'__VkDVzaXOmnQE8XmKW8k6UWWufiR1o0n4yrKYQjtyh7w');
./src
__VkDVzaXOmnQE8XmKW8k6UWWufiR1o0n4yrKYQjtyh7w

meta::data('table-of-contents', <<'__a4ayc/80/OGda4BO/1o/V0etpOqiLx1JwB5S3beHW0s');
1
__a4ayc/80/OGda4BO/1o/V0etpOqiLx1JwB5S3beHW0s

meta::data('tex', <<'__36pVFkgFfbTr/DrquMMaLrTY5F5S/VJ5Z3Jc90KC+q4');
latex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__
__36pVFkgFfbTr/DrquMMaLrTY5F5S/VJ5Z3Jc90KC+q4

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clean', <<'__YiaR22ZfeeFhhPYBUFHWBZqstuOzKtkv2XqmTuXhy1E');
my $output_directory = &{'pdf-output-file'}();
$output_directory =~ s+/.*++g;
unlink <$output_directory/*>;
rmdir $output_directory;
__YiaR22ZfeeFhhPYBUFHWBZqstuOzKtkv2XqmTuXhy1E

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('compile', <<'__BGic8KOk19AvsJI5t2yZ/R/ONbJ+lvK9Yy4EB15Zib4');
my $tex_command         = tex();
my $pdftex_command      = pdftex();
my $filename            = 'document';

my $contents            = &{'compile-to-tex'}();
my $output_directory    = &{'output-dir'}();
chomp $output_directory;

my $temporary_directory = state_based_filename();
$temporary_directory =~ s+^.*/++;
$temporary_directory = "$output_directory/$temporary_directory";

$tex_command    =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$tex_command    =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

$pdftex_command =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$pdftex_command =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

mkdir $temporary_directory;
file::write("$temporary_directory/$filename.tex", $contents);

my $result = &{'table-of-contents'}() ? system($tex_command) || system($tex_command) || system($pdftex_command) : system($pdftex_command);

associate('data::pdf-output-file', "$temporary_directory/$filename.pdf", execute => 1);
$result;
__BGic8KOk19AvsJI5t2yZ/R/ONbJ+lvK9Yy4EB15Zib4

meta::function('compile-to-tex', <<'__cvWyD1kaLfBVnSppeGw/hSpleoWxLARJQwP1tUKvebc');
my ($document) = document();
$document = &$_($document) for (grep /^unlit_converter::/, sort keys %data);
$document;
__cvWyD1kaLfBVnSppeGw/hSpleoWxLARJQwP1tUKvebc

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc

meta::function('e', <<'__VOcQy5WG275NZGlFODdYHYBe3oJ7/CHmTT/L9O1I6t0');
edit('data::document', extension => '.tex');
reload();
__VOcQy5WG275NZGlFODdYHYBe3oJ7/CHmTT/L9O1I6t0

meta::function('edit', <<'__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
delete $data{$name} if length($data{$name}) == 0;

save();
__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('export', <<'__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map {cat($_)} @attributes;
  file::write ($name, $file);
} else {
  messages::error ("Not enough arguments");
}
__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8

meta::function('files', <<'__m7EeTwfWa+KNekunGpnyF77ZE5n0qlaCzK70nPgXk4o');
# Quickly generate files
terminal::message('status', 'Generating files from main document...');
&{'compile-to-tex'}();
terminal::message('status', 'Done.');
__m7EeTwfWa+KNekunGpnyF77ZE5n0qlaCzK70nPgXk4o

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('import', <<'__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__OlQOgKhp6VUThx34wxmM3MFkwsHfR/c8dqvu07z059E');
my $criteria = join '|', @_;
my @lines = grep /$criteria/, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__OlQOgKhp6VUThx34wxmM3MFkwsHfR/c8dqvu07z059E

meta::function('ls-a', <<'__S5EydJRu+YIfcFmTMz1ZHX0cANJq32bU5JnYCe1tWdk');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__S5EydJRu+YIfcFmTMz1ZHX0cANJq32bU5JnYCe1tWdk

meta::function('make', <<'__iyMeXI5V4AfTzDMQu6wYbr6t/bNwBMAeh7RxjklLF7E');
compile() || view();
clean();
__iyMeXI5V4AfTzDMQu6wYbr6t/bNwBMAeh7RxjklLF7E

meta::function('mv', <<'__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
associate($to, retrieve($from));
rm($from);
__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4

meta::function('new', <<'__FQjehdFg7T3T2iHPMlGp6nAnrKAsQUIK5CXW02wNnos');
clone(@_);
__FQjehdFg7T3T2iHPMlGp6nAnrKAsQUIK5CXW02wNnos

meta::function('perl', <<'__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA');
my $result = eval($_[0]);
$@ ? $@ : $result;
__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA

meta::function('pop-state', <<'__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('push-state', <<'__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk

meta::function('reload', <<'__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM

meta::function('render', <<'__3oK0CSm8flucLHFYkqn7EbxALXkyMvhecwh2/P/KWhA');
use File::Copy 'cp';

terminal::message('status', 'Building PDF...');
compile();
terminal::message('status', 'Copying PDF to source directory');
cp(&{'pdf-output-file'}(), &{'source-directory'} . '/' . name() . '.pdf');
__3oK0CSm8flucLHFYkqn7EbxALXkyMvhecwh2/P/KWhA

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('save', <<'__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'name'}() . '$ ';
}
__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('update-from', <<'__jJ2tfSk/Quz8/1PiYxIwQjBRt/hYg51iJhAdxcdaHkM');
# Upgrade all attributes that aren't customized. In this case, we want everything except for configuration::, code::, and attribute::.
return "That is a really bad idea." if $0 =~ /\.\/(.*)/ && $_[0] eq $1 || $_[0] eq $0;

my @attributes = map {s/\s+.*//; $_} split(/\n/, qx|$_[0] ls-a|);

terminal::message('info', 'Replicating state...');
&{'push-state'}();
terminal::message('info', 'Updating meta attributes...');
for my $attribute (grep length && /^meta::/, @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();
  print '.';
}

print "\n";
terminal::message('info', 'Updating non-meta attributes...');
for my $attribute (grep length && ! (/^configuration::/ || /^code::/ || /^attribute::/ || /^function::pop-state$/ ||
                                     /^list::/ || /^issue::/ || /^data::/ || /^meta::datatypes/), @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();     # Necessary to activate new datatypes.
  print '.';
}

print "\n";
terminal::message('info', 'Reloading new configuration');
reload();
terminal::message('info', "Imported from $_[0]. Run pop-state to undo this change.");
__jJ2tfSk/Quz8/1PiYxIwQjBRt/hYg51iJhAdxcdaHkM

meta::function('usage', <<'__7ReV+2xSkKaDnXAdgszTEQyeJETOBChyE/THZJIifMs');
<<"EOD" . ls ();
Usage: $0 [options] action [arguments]
Defined actions (and the attribute that defines them):
EOD
__7ReV+2xSkKaDnXAdgszTEQyeJETOBChyE/THZJIifMs

meta::function('view', <<'__wEtlK5H0ttR24UvcFUsgg5Es1V/VbjMJlU+SKiO2jKs');
my $pdf_reader      = &{'pdf-reader'}();
my $pdf_output_file = &{'pdf-output-file'}();
chomp $pdf_reader;
system("$pdf_reader '$pdf_output_file'");
__wEtlK5H0ttR24UvcFUsgg5Es1V/VbjMJlU+SKiO2jKs

meta::function('vim', <<'__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('complete', <<'__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg

meta::internal_function('execute', <<'__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM');
@data{@_};
__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::java_section('java-introduction', <<'__A3KF4Pr3gD/4XG4sMrPH+Ak7OpswEl/WQAmdOK9Isp8');
- Introduction to Java Literate Coding
  Literate coding allows you to write \TeX{} primarily, but insert Java code snippets where appropriate.\footnote{Take a look at {\tt java\_section::java-introduction} to see the how to set
  the language and options for code sections.} For example:

  :: java class=test
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is a test class");
    }
  }
  :.

  :: java class=test package=com.spencertipping
  package com.spencertipping;
  public class test {
    public static void main (String[] args) {
      System.out.println ("This is in package com.spencertipping.");
    }
  }
  :.

  Compiling the system is also simple:

  ::
  $ ./my-project compile
  :.

  This generates all of the Java source files in a directory, usually {\tt /tmp/src/}. The output directory can be changed like this:

  ::
  $ ./my-project source-directory = src/
  :.
__A3KF4Pr3gD/4XG4sMrPH+Ak7OpswEl/WQAmdOK9Isp8

meta::library('terminal', <<'__pvD00lNNeQAXRGZFRNjR0bf9b/Z/rZgMgNL5zN4ZsQA');
# Functions for nice-looking terminal output.

package terminal;

my %color_conversions = (black  => "0;0",
                         red    => "1;31",
                         yellow => "1;33",
                         green  => "1;32",
                         blue   => "1;34",
                         purple => "1;35",
                         cyan   => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);
  print STDERR "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__pvD00lNNeQAXRGZFRNjR0bf9b/Z/rZgMgNL5zN4ZsQA

meta::line_filter('convert_header_info', <<'__1jqqbjBcdOqh/3nTKZSDbW1AgEo4kg0dQ5HdRAgxyzE');
my ($line) = @_;

$line =~ s/^= (.*)$/\\title{$1}/;
$line =~ s/^a (.*)$/\\author{$1}/;
$line =~ s/^d (.*)$/\\date{$1}/;

my $document_header = '\begin{document}\maketitle';
$document_header .= '\tableofcontents' if &{'table-of-contents'}();

$line =~ s/^begin$/$document_header/;

$line;
__1jqqbjBcdOqh/3nTKZSDbW1AgEo4kg0dQ5HdRAgxyzE

meta::line_filter('convert_itemized_environments', <<'__crKVW6OfRA2nN2SGPWQ/DAD9NPUws+boS8dK4cf3X2I');
my ($line) = @_;

$line =~ s/^\s*\+ /\\item /;
$line =~ s/^\s*\+\[([^\]]*)\] /\\item[\1] /;

$line =~ s/^\s*e\[$/\\begin{enumerate}/;
$line =~ s/^\s*i\[$/\\begin{itemize}/;
$line =~ s/^\s*d\[$/\\begin{description}/;

$line =~ s/^\s*a\[$/\\begin{align*}/;

$line =~ s/^\s*\]e$/\\end{enumerate}/;
$line =~ s/^\s*\]i$/\\end{itemize}/;
$line =~ s/^\s*\]d$/\\end{description}/;

$line =~ s/^\s*\]a$/\\end{align*}/;

$line;
__crKVW6OfRA2nN2SGPWQ/DAD9NPUws+boS8dK4cf3X2I

meta::line_filter('convert_sections', <<'__2dvR+HcKtutFCWe6cEFSERoj36PbA6u91tQcJgcwJWk');
my ($line) = @_;

my %indentation_levels = (
  0 => '\section',
  2 => '\subsection',
  4 => '\subsubsection',
  6 => '\paragraph',
  8 => '\subparagraph');

if ($line =~ /^(\s*)- (.*)$/) {
  my $section = $indentation_levels{length($1)} || die "Invalid indentation level:\n$_";
  my $section_name = $2;
  my $label_name   = lc $section_name;

  $label_name =~ s/[^A-Za-z0-9.]/-/g;

  "${section} {$section_name} \\label{sec:$label_name}";
} else {
  $line;
}
__2dvR+HcKtutFCWe6cEFSERoj36PbA6u91tQcJgcwJWk

meta::unlit_converter('create_sections', <<'__hMABUTlrgmVTt4JFwi0HvAb2ehkYaGLJ25qslKDQurE');
my ($document) = @_;
1 while $document =~ s/^\s*%section\(([^)]+)\)\s*$/\n$data{$1}\n/omg;
$document;
__hMABUTlrgmVTt4JFwi0HvAb2ehkYaGLJ25qslKDQurE

meta::unlit_converter('main', <<'__3D082OWBmT2cWw4D6ktyDGp1MHknawaTDW2B0gvZPyM');
my ($document) = @_;

my $sections_already_encountered = 0;
my $inside_code_block            = 0;
my $code_block_indentation       = 0;
my $code_section_name            = '';
my $result                       = '';

for (split /\n/, $document) {
  # Handle code blocks.
  if (/^(\s*):\.$/) {
    $inside_code_block = $code_block_indentation = 0;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, end => 1);
    }
  }

  if ($inside_code_block) {
    my $spaces_to_delete = ' ' x $code_block_indentation;
    s/^$spaces_to_delete//;
    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation);
    }
  } else {
    for my $filter_name (grep /^line_filter::/, sort keys %data) {
      $_ = &$filter_name($_);
    }
  }

  if (/^(\s*)::(\s.*)?$/) {
    $inside_code_block      = 1;
    $code_block_indentation = length($1);
    $code_section_name      = $2;

    for my $filter_name (grep /^code_filter::/, sort keys %data) {
      $_ = &$filter_name($_, name => $code_section_name, indentation => $code_block_indentation, begin => 1);
    }
  }

  $result .= "$_\n";
}

$result;
__3D082OWBmT2cWw4D6ktyDGp1MHknawaTDW2B0gvZPyM

meta::unlit_converter('zz_append_footer', <<'__xZrf+gAwEiK7btRcm+mwC/qtHsXp2FQ/Z8ZCwMvSw4Q');
my ($document) = @_;
"$document\n\\end{document}";
__xZrf+gAwEiK7btRcm+mwC/qtHsXp2FQ/Z8ZCwMvSw4Q

meta::unlit_converter('zz_prepend_header', <<'__4YCmTeTBS/MGOkeIFkQRlLujLJ1g/qS0/0iCeanWkkw');
my ($document) = @_;
header() . "\n$document";
__4YCmTeTBS/MGOkeIFkQRlLujLJ1g/qS0/0iCeanWkkw

meta::vim_highlighter('cltex', <<'__i99D+bM2oHb2kJ9JHMYOpio7eDlvgAvVVrOhkUTyaxM');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match  cltTitle   /^= .*$/
syn match  cltAuthor  /^a .*$/
syn match  cltDate    /^d .*$/
syn match  cltBegin   /^begin$/
syn match  cltSection /^\s*- .*$/
syn region cltVerbatim start=/^\s*::$/ end=/^\s*:\.$/

syn match  cltEnumeratedThing /^\s*[eid]\[/
syn match  cltEnumeratedThing /^\s*\][eid]/
syn match  cltItem            /^\s*+\s/
syn match  cltQuantifiedItem  /^\s*+\[[^\]]*\]\s/

runtime! syntax/tex.vim

syn match  cltInclude /^\s*%section([^)]\+)$/

hi link cltBegin    Keyword
hi link cltTitle    Identifier
hi link cltAuthor   Identifier
hi link cltDate     Identifier

hi link cltEnumeratedThing Special
hi link cltItem            Special
hi link cltQuantifiedItem  Special
hi link cltInclude         Special

hi link cltSection  Type

hi link cltVerbatim String

let b:current_syntax = "cltex"
__i99D+bM2oHb2kJ9JHMYOpio7eDlvgAvVVrOhkUTyaxM

meta::vim_highlighter('cpptex', <<'__2H5AUY+IdhatqTOdpiXUmgcnlKmzCJsLpcRGMNUHyB0');
" TeX with C++
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with C++ in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region cpptexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<cpp\>.*$/ contains=cpptexSection
syn match  cpptexSection /^\s*- .*$/ contained

runtime! syntax/cpp.vim

syn match  cpptexInclude /#include\s\+\(\w\|[_()]\)\+/

hi link cpptexSection Special
hi link cpptexComment Comment
hi link cpptexInclude PreProc

let b:current_syntax = "cpptex"
__2H5AUY+IdhatqTOdpiXUmgcnlKmzCJsLpcRGMNUHyB0

meta::vim_highlighter('javatex', <<'__nEheNk5KhfU1tIJUV7PcB9MfRb0bIbRXyu7BN/Ws6bU');
" TeX with Java
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   TeX with Java in it

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn region javatexComment start=/\%^\|^\s*:.$/ end=/\%$\|^\s*::.*\<java\>.*$/ contains=javatexSection
syn match  javatexSection /^\s*- .*$/           contained

runtime! syntax/java.vim

hi link javatexSection Special
hi link javatexComment Comment

let b:current_syntax = "javatex"
__nEheNk5KhfU1tIJUV7PcB9MfRb0bIbRXyu7BN/Ws6bU

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__